<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tropical Synthwave Background</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background: #0a1628;
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
  }
</style>
</head>
<body>
<canvas id="bg"></canvas>
<script>
const canvas = document.getElementById('bg');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
  W = canvas.width = window.innerWidth * devicePixelRatio;
  H = canvas.height = window.innerHeight * devicePixelRatio;
}
resize();
window.addEventListener('resize', resize);

// --- COLOR PALETTE ---
// Muted tropical teal (#2c8f7b) + warm orange, tuned for island theme
const COLORS = {
  skyTop: '#0a0f1e',
  skyMid: '#0d2137',
  skyLow: '#1a3a4a',
  horizon: '#0f3542',
  sunTop: '#ff6b35',
  sunMid: '#ff9f1c',
  sunBot: '#ffe66d',
  water: '#0a2a3a',
  waterHighlight: '#2c8f7b',
  waterDeep: '#061a28',
  palmTrunk: '#1a3025',
  palmFrond: '#0d6b3a',
  palmFrondLight: '#2c8f7b',
  sand: '#c2956a',
  sandDark: '#8a6842',
  parrotBody: '#e05a2b',
  parrotWing: '#2c8f7b',
  parrotBeak: '#e6cf63',
  stars: '#ffffff',
  glow: 'rgba(44, 143, 123, 0.1)',
  cloudBase: 'rgba(20, 80, 100, 0.3)',
  foam: 'rgba(220, 245, 255, 0.6)',
  foamFade: 'rgba(180, 230, 240, 0.15)',
};

// --- STARS ---
const stars = [];
for (let i = 0; i < 120; i++) {
  stars.push({
    x: Math.random() * 1.2 - 0.1,
    y: Math.random() * 0.4,
    r: Math.random() * 1.5 + 0.3,
    twinkle: Math.random() * Math.PI * 2,
    speed: Math.random() * 1.5 + 0.5,
  });
}

// --- SHOOTING STARS ---
const shootingStars = [];
function spawnShootingStar() {
  shootingStars.push({
    x: Math.random() * 0.6 + 0.1,
    y: Math.random() * 0.2 + 0.02,
    vx: (Math.random() * 0.3 + 0.2) * (Math.random() > 0.5 ? 1 : -1),
    vy: Math.random() * 0.15 + 0.08,
    life: 1.0,
    decay: 0.008 + Math.random() * 0.01,
    len: 0.03 + Math.random() * 0.02,
  });
}

// --- CLOUDS (layered puffy structure) ---
const clouds = [];
for (let i = 0; i < 8; i++) {
  const cx = Math.random() * 1.4 - 0.2;
  const cy = 0.08 + Math.random() * 0.18;
  const baseW = 0.06 + Math.random() * 0.12;
  // Each cloud is a cluster of 3-5 overlapping ellipses
  const puffs = [];
  const puffCount = 3 + Math.floor(Math.random() * 3);
  for (let p = 0; p < puffCount; p++) {
    puffs.push({
      ox: (Math.random() - 0.5) * baseW * 0.8,
      oy: (Math.random() - 0.5) * 0.008,
      w: baseW * (0.4 + Math.random() * 0.6),
      h: 0.006 + Math.random() * 0.01,
      opacity: 0.08 + Math.random() * 0.12,
    });
  }
  clouds.push({
    x: cx,
    y: cy,
    puffs: puffs,
    speed: (Math.random() * 0.3 + 0.1) * 0.00008,
  });
}

// --- DISTANT BIRDS ---
const distantBirds = [];
for (let i = 0; i < 5; i++) {
  distantBirds.push({
    x: Math.random() * 0.6 + 0.2,
    y: 0.12 + Math.random() * 0.15,
    speed: 0.00003 + Math.random() * 0.00004,
    flapPhase: Math.random() * Math.PI * 2,
    flapSpeed: 3 + Math.random() * 2,
    size: 3 + Math.random() * 4,
  });
}

// --- PARROTS ---
class Parrot {
  constructor(startX, startY, size, delay) {
    this.baseX = startX;
    this.baseY = startY;
    this.size = size;
    this.delay = delay;
    this.flapPhase = Math.random() * Math.PI * 2;
    this.driftPhase = Math.random() * Math.PI * 2;
  }

  draw(t) {
    const time = t * 0.001 + this.delay;
    const x = (this.baseX + Math.sin(this.driftPhase + time * 0.3) * 0.03) * W;
    const y = (this.baseY + Math.sin(time * 0.5) * 0.015 + Math.cos(time * 0.7) * 0.008) * H;
    const s = this.size * Math.min(W, H) * 0.001;
    const wingAngle = Math.sin(time * 6 + this.flapPhase) * 0.6;

    ctx.save();
    ctx.translate(x, y);

    // Body
    ctx.fillStyle = COLORS.parrotBody;
    ctx.beginPath();
    ctx.ellipse(0, 0, s * 3, s * 1.2, 0.1, 0, Math.PI * 2);
    ctx.fill();

    // Head
    ctx.fillStyle = '#ff8c42';
    ctx.beginPath();
    ctx.arc(s * 2.5, -s * 0.4, s * 1.1, 0, Math.PI * 2);
    ctx.fill();

    // Eye
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(s * 2.9, -s * 0.6, s * 0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.arc(s * 3.0, -s * 0.6, s * 0.15, 0, Math.PI * 2);
    ctx.fill();

    // Beak
    ctx.fillStyle = COLORS.parrotBeak;
    ctx.beginPath();
    ctx.moveTo(s * 3.5, -s * 0.3);
    ctx.lineTo(s * 4.2, -s * 0.1);
    ctx.lineTo(s * 3.5, s * 0.2);
    ctx.closePath();
    ctx.fill();

    // Wings
    ctx.save();
    ctx.translate(0, -s * 0.3);
    ctx.rotate(wingAngle);
    ctx.fillStyle = COLORS.parrotWing;
    ctx.beginPath();
    ctx.ellipse(-s * 0.5, -s * 1, s * 2.5, s * 1, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(44, 143, 123, 0.5)';
    ctx.beginPath();
    ctx.ellipse(-s * 0.2, -s * 0.6, s * 1.8, s * 0.7, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Tail
    ctx.fillStyle = '#2c8f7b';
    ctx.beginPath();
    ctx.moveTo(-s * 2.5, s * 0.2);
    ctx.quadraticCurveTo(-s * 4, s * 0.8, -s * 5, s * 1.5);
    ctx.quadraticCurveTo(-s * 4, s * 0.3, -s * 2.5, -s * 0.3);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#ff6b35';
    ctx.beginPath();
    ctx.moveTo(-s * 2.5, s * 0);
    ctx.quadraticCurveTo(-s * 3.8, s * 0.5, -s * 4.5, s * 1.8);
    ctx.quadraticCurveTo(-s * 3.5, s * 0.5, -s * 2.5, -s * 0.2);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }
}

const parrots = [
  new Parrot(0.18, 0.18, 5, 0),
  new Parrot(0.25, 0.14, 4, 2),
  new Parrot(0.78, 0.16, 4.5, 4),
  new Parrot(0.85, 0.22, 3.5, 1),
];

// --- PALM TREE ---
function drawPalmFrond(cx, cy, angle, length, curve, swayOffset) {
  const segments = 20;
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(angle + swayOffset);

  ctx.strokeStyle = '#0b5e34';
  ctx.lineWidth = Math.max(1, length * 0.03);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  for (let i = 1; i <= segments; i++) {
    const t = i / segments;
    const x = t * length;
    const y = Math.sin(t * Math.PI * curve) * length * 0.15;
    ctx.lineTo(x, y);
  }
  ctx.stroke();

  for (let i = 2; i <= segments; i++) {
    const t = i / segments;
    const x = t * length;
    const y = Math.sin(t * Math.PI * curve) * length * 0.15;
    const leafLen = length * 0.18 * (1 - t * 0.5);

    const grad = ctx.createLinearGradient(x, y, x, y - leafLen);
    grad.addColorStop(0, COLORS.palmFrond);
    grad.addColorStop(1, 'rgba(13, 107, 58, 0.2)');

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.quadraticCurveTo(x + leafLen * 0.3, y - leafLen * 0.7, x + leafLen * 0.1, y - leafLen);
    ctx.quadraticCurveTo(x - leafLen * 0.1, y - leafLen * 0.5, x, y);
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.quadraticCurveTo(x + leafLen * 0.3, y + leafLen * 0.7, x + leafLen * 0.1, y + leafLen);
    ctx.quadraticCurveTo(x - leafLen * 0.1, y + leafLen * 0.5, x, y);
    ctx.fill();
  }

  ctx.restore();
}

// Silhouette frond for foreground palms
function drawSilhouetteFrond(cx, cy, angle, length, curve, swayOffset) {
  const segments = 20;
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(angle + swayOffset);

  ctx.fillStyle = '#050e0a';
  ctx.beginPath();
  ctx.moveTo(0, 0);

  for (let i = 0; i <= segments; i++) {
    const t = i / segments;
    const x = t * length;
    const y = Math.sin(t * Math.PI * curve) * length * 0.15;
    const leafLen = length * 0.18 * (1 - t * 0.5);
    ctx.lineTo(x, y - leafLen * 0.85);
  }

  const tipX = length;
  const tipY = Math.sin(Math.PI * curve) * length * 0.15;
  ctx.lineTo(tipX, tipY);

  for (let i = segments; i >= 0; i--) {
    const t = i / segments;
    const x = t * length;
    const y = Math.sin(t * Math.PI * curve) * length * 0.15;
    const leafLen = length * 0.18 * (1 - t * 0.5);
    ctx.lineTo(x, y + leafLen * 0.85);
  }

  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawPalmTree(x, y, height, sway, leanAngle, silhouette) {
  const trunkW = height * 0.04;

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(leanAngle);

  if (silhouette) {
    ctx.fillStyle = '#050e0a';
    ctx.beginPath();
    ctx.moveTo(-trunkW, 0);
    ctx.lineTo(trunkW, 0);
    ctx.lineTo(trunkW * 0.6, -height);
    ctx.lineTo(-trunkW * 0.6, -height);
    ctx.closePath();
    ctx.fill();
  } else {
    const trunkSegments = 15;
    for (let i = 0; i < trunkSegments; i++) {
      const t1 = i / trunkSegments;
      const t2 = (i + 1) / trunkSegments;
      const y1 = -t1 * height;
      const y2 = -t2 * height;
      const w1 = trunkW * (1 - t1 * 0.4);
      const w2 = trunkW * (1 - t2 * 0.4);

      const shade = 0.3 + (i % 2 === 0 ? 0 : 0.08);
      ctx.fillStyle = `rgba(26, 48, 37, ${shade + 0.4})`;
      ctx.beginPath();
      ctx.moveTo(-w1, y1);
      ctx.lineTo(w1, y1);
      ctx.lineTo(w2, y2);
      ctx.lineTo(-w2, y2);
      ctx.closePath();
      ctx.fill();
    }
  }

  const topX = 0;
  const topY = -height;
  const frondLen = height * 0.55;
  const frondCount = 8;
  const drawFn = silhouette ? drawSilhouetteFrond : drawPalmFrond;

  for (let i = 0; i < frondCount; i++) {
    const angle = (i / frondCount) * Math.PI * 2 - Math.PI / 2;
    const curvature = 0.8 + Math.sin(i * 1.3) * 0.3;
    drawFn(topX, topY, angle, frondLen, curvature, sway * (0.8 + Math.sin(i) * 0.3));
  }

  if (!silhouette) {
    ctx.fillStyle = '#5a3a1a';
    for (let i = 0; i < 3; i++) {
      const angle = (i / 3) * Math.PI * 2;
      const cx = topX + Math.cos(angle) * trunkW * 1.5;
      const cy = topY + Math.sin(angle) * trunkW + trunkW;
      ctx.beginPath();
      ctx.arc(cx, cy, height * 0.02, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.restore();
}

// --- ISLAND ---
function drawIsland(t) {
  const cx = W * 0.5;
  const baseY = H * 0.52;
  const iw = W * 0.35;
  const ih = H * 0.06;
  const time = t * 0.001;

  // Sandy island shape
  const sandGrad = ctx.createRadialGradient(cx, baseY, 0, cx, baseY, iw);
  sandGrad.addColorStop(0, COLORS.sand);
  sandGrad.addColorStop(0.7, COLORS.sandDark);
  sandGrad.addColorStop(1, 'rgba(138, 104, 66, 0)');
  ctx.fillStyle = sandGrad;
  ctx.beginPath();
  ctx.ellipse(cx, baseY, iw, ih, 0, 0, Math.PI * 2);
  ctx.fill();

  // Vegetation base
  ctx.fillStyle = 'rgba(13, 107, 58, 0.4)';
  ctx.beginPath();
  ctx.ellipse(cx, baseY - ih * 0.3, iw * 0.7, ih * 0.6, 0, Math.PI, Math.PI * 2);
  ctx.fill();

  // Small vegetation tufts along the island
  for (let i = 0; i < 12; i++) {
    const angle = Math.PI + (i / 12) * Math.PI; // top half of ellipse only
    const tuftX = cx + Math.cos(angle) * iw * 0.6;
    const tuftBaseY = baseY - ih * 0.3 + Math.sin(angle) * ih * 0.4;
    const tuftH = ih * (0.6 + Math.sin(i * 2.7) * 0.3);
    const sway2 = Math.sin(time * 1.2 + i * 1.5) * 2;

    ctx.fillStyle = `rgba(13, ${80 + Math.floor(Math.sin(i * 1.3) * 20)}, ${45 + Math.floor(Math.sin(i * 2.1) * 15)}, 0.5)`;
    ctx.beginPath();
    ctx.moveTo(tuftX - 4, tuftBaseY);
    ctx.quadraticCurveTo(tuftX + sway2, tuftBaseY - tuftH, tuftX + 4, tuftBaseY);
    ctx.fill();
  }

  // --- ANIMATED SURF / FOAM ---
  for (let ring = 0; ring < 4; ring++) {
    const phase = time * 1.2 + ring * 1.6;
    const breathe = Math.sin(phase) * 0.5 + 0.5;
    const ringScale = 1.02 + ring * 0.03 + breathe * 0.03;
    const foamAlpha = (1 - breathe) * 0.35 * (1 - ring * 0.2);

    ctx.strokeStyle = `rgba(220, 245, 255, ${foamAlpha})`;
    ctx.lineWidth = 2.5 - ring * 0.4;
    ctx.beginPath();
    const steps = 60;
    for (let i = 0; i <= steps; i++) {
      const a = (i / steps) * Math.PI * 2;
      const waveOffset = Math.sin(a * 8 + time * 2 + ring) * ih * 0.08;
      const rx = iw * ringScale;
      const ry = (ih * 0.7 + ring * ih * 0.2) * ringScale;
      const px = cx + Math.cos(a) * rx;
      const py = baseY + Math.sin(a) * ry + waveOffset;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.stroke();

    if (ring < 2) {
      ctx.strokeStyle = `rgba(44, 143, 123, ${foamAlpha * 0.25})`;
      ctx.lineWidth = 5;
      ctx.stroke();
    }
  }

  // Foam speckles near shoreline
  for (let i = 0; i < 20; i++) {
    const angle = (i / 20) * Math.PI * 2;
    const dist = 1.02 + Math.sin(time * 1.5 + i * 3) * 0.02;
    const fx = cx + Math.cos(angle) * iw * dist;
    const fy = baseY + Math.sin(angle) * ih * 0.8 * dist;
    const speckleAlpha = 0.15 + Math.sin(time * 3 + i * 5) * 0.15;
    ctx.fillStyle = `rgba(255, 255, 255, ${Math.max(0, speckleAlpha)})`;
    ctx.beginPath();
    ctx.arc(fx, fy, 1.5 + Math.sin(time + i) * 0.8, 0, Math.PI * 2);
    ctx.fill();
  }
}

// --- SUN ---
function drawSun(t) {
  const cx = W * 0.5;
  const cy = H * 0.33;
  const r = Math.min(W, H) * 0.08;
  const time = t * 0.001;

  // Outer glow rings
  for (let i = 4; i > 0; i--) {
    const glowR = r * (1 + i * 0.6);
    const alpha = 0.04 * (1 + Math.sin(time + i) * 0.3);
    const grad = ctx.createRadialGradient(cx, cy, r * 0.5, cx, cy, glowR);
    grad.addColorStop(0, `rgba(255, 159, 28, ${alpha})`);
    grad.addColorStop(0.5, `rgba(255, 107, 53, ${alpha * 0.5})`);
    grad.addColorStop(1, 'rgba(255, 107, 53, 0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(cx, cy, glowR, 0, Math.PI * 2);
    ctx.fill();
  }

  // Sun body with horizontal slice effect
  const grad = ctx.createLinearGradient(cx, cy - r, cx, cy + r);
  grad.addColorStop(0, COLORS.sunTop);
  grad.addColorStop(0.5, COLORS.sunMid);
  grad.addColorStop(1, COLORS.sunBot);

  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.clip();

  ctx.fillStyle = grad;
  ctx.fillRect(cx - r, cy - r, r * 2, r * 2);

  // Horizontal slices (synthwave sun)
  ctx.fillStyle = COLORS.skyMid;
  const sliceCount = 8;
  for (let i = 0; i < sliceCount; i++) {
    const sliceY = cy + r * 0.1 + (i / sliceCount) * r * 0.9;
    const sliceH = (i + 1) * 1.2;
    ctx.fillRect(cx - r, sliceY, r * 2, sliceH);
  }
  ctx.restore();
}

// --- ATMOSPHERIC HAZE ---
// Warm haze layers between sky and horizon for tropical depth
function drawAtmosphericHaze(t) {
  const time = t * 0.001;
  const horizonY = H * 0.55;

  // Warm orange haze band above horizon
  const hazeGrad = ctx.createLinearGradient(0, horizonY - H * 0.15, 0, horizonY);
  hazeGrad.addColorStop(0, 'rgba(255, 107, 53, 0)');
  hazeGrad.addColorStop(0.5, `rgba(255, 140, 60, ${0.02 + Math.sin(time * 0.3) * 0.008})`);
  hazeGrad.addColorStop(1, `rgba(255, 107, 53, ${0.04 + Math.sin(time * 0.4) * 0.01})`);
  ctx.fillStyle = hazeGrad;
  ctx.fillRect(0, horizonY - H * 0.15, W, H * 0.15);

  // Teal atmospheric mist drifting just above water
  for (let i = 0; i < 3; i++) {
    const mistX = (0.2 + i * 0.3 + Math.sin(time * 0.15 + i * 2) * 0.08) * W;
    const mistY = horizonY - H * 0.02;
    const mistW = W * (0.15 + Math.sin(time * 0.2 + i) * 0.03);
    const mistH = H * 0.04;
    const mistAlpha = 0.03 + Math.sin(time * 0.25 + i * 1.5) * 0.01;

    const mistGrad = ctx.createRadialGradient(mistX, mistY, 0, mistX, mistY, mistW);
    mistGrad.addColorStop(0, `rgba(44, 143, 123, ${mistAlpha})`);
    mistGrad.addColorStop(1, 'rgba(44, 143, 123, 0)');
    ctx.fillStyle = mistGrad;
    ctx.beginPath();
    ctx.ellipse(mistX, mistY, mistW, mistH, 0, 0, Math.PI * 2);
    ctx.fill();
  }
}

// --- HORIZON GLOW BAND ---
function drawHorizonGlow(t) {
  const horizonY = H * 0.55;
  const time = t * 0.001;
  const bandH = H * 0.06;

  const tealGrad = ctx.createLinearGradient(0, horizonY - bandH, 0, horizonY + bandH * 0.5);
  tealGrad.addColorStop(0, 'rgba(44, 143, 123, 0)');
  tealGrad.addColorStop(0.4, `rgba(44, 143, 123, ${0.04 + Math.sin(time * 0.5) * 0.015})`);
  tealGrad.addColorStop(0.5, `rgba(44, 143, 123, ${0.08 + Math.sin(time * 0.7) * 0.02})`);
  tealGrad.addColorStop(0.6, `rgba(255, 107, 53, ${0.04 + Math.sin(time * 0.6) * 0.015})`);
  tealGrad.addColorStop(1, 'rgba(255, 107, 53, 0)');
  ctx.fillStyle = tealGrad;
  ctx.fillRect(0, horizonY - bandH, W, bandH * 1.5);

  // Bright horizon line
  ctx.strokeStyle = `rgba(44, 143, 123, ${0.12 + Math.sin(time) * 0.04})`;
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(0, horizonY);
  ctx.lineTo(W, horizonY);
  ctx.stroke();
}

// --- WATER / OCEAN ---
function drawOcean(t) {
  const horizonY = H * 0.55;
  const time = t * 0.001;

  // Base water gradient
  const waterGrad = ctx.createLinearGradient(0, horizonY, 0, H);
  waterGrad.addColorStop(0, COLORS.water);
  waterGrad.addColorStop(0.5, COLORS.waterDeep);
  waterGrad.addColorStop(1, '#030e18');
  ctx.fillStyle = waterGrad;
  ctx.fillRect(0, horizonY, W, H - horizonY);

  // --- ROLLING SWELLS ---
  // Broad sine-wave swells that shift the surface, drawn as filled bands
  for (let i = 0; i < 5; i++) {
    const t2 = (i + 2) / 20;
    const baseYSwell = horizonY + Math.pow(t2, 1.5) * (H - horizonY);
    const swellH = 4 + i * 2;
    const swellAlpha = 0.025 * (1 - t2);

    ctx.fillStyle = `rgba(44, 143, 123, ${Math.max(0, swellAlpha)})`;
    ctx.beginPath();
    ctx.moveTo(0, baseYSwell + swellH);
    for (let x = 0; x <= W; x += W / 80) {
      const swell = Math.sin(time * 0.6 + x * 0.002 + i * 1.2) * swellH;
      const ripple = Math.sin(time * 1.5 + x * 0.008 + i * 3) * 1.5;
      ctx.lineTo(x, baseYSwell + swell + ripple);
    }
    ctx.lineTo(W, baseYSwell + swellH);
    ctx.closePath();
    ctx.fill();
  }

  // Synthwave grid on water
  ctx.strokeStyle = 'rgba(44, 143, 123, 0.05)';
  ctx.lineWidth = 1;

  // Horizontal lines with perspective
  const numH = 25;
  for (let i = 0; i < numH; i++) {
    const t2 = i / numH;
    const y = horizonY + Math.pow(t2, 1.8) * (H - horizonY);
    const waveOffset = Math.sin(time * 0.8 + i * 0.5) * 3;
    ctx.globalAlpha = t2 * 0.6;
    ctx.beginPath();
    ctx.moveTo(0, y + waveOffset);
    for (let x = 0; x <= W; x += W / 40) {
      const wave = Math.sin(time + x * 0.003 + i * 0.3) * (2 + t2 * 5);
      ctx.lineTo(x, y + waveOffset + wave);
    }
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // Vertical converging lines
  const numV = 20;
  const vanishX = W * 0.5;
  ctx.strokeStyle = 'rgba(44, 143, 123, 0.03)';
  for (let i = 0; i < numV; i++) {
    const spread = (i - numV / 2) / (numV / 2);
    const bottomX = vanishX + spread * W * 0.8;
    ctx.beginPath();
    ctx.moveTo(vanishX, horizonY);
    ctx.lineTo(bottomX, H);
    ctx.stroke();
  }

  // --- BIOLUMINESCENT WAVE CRESTS ---
  for (let i = 0; i < 8; i++) {
    const t2 = (i + 1) / 30;
    const y = horizonY + Math.pow(t2, 1.8) * (H - horizonY);
    const waveOffset = Math.sin(time * 0.8 + i * 0.5) * 3;
    const alpha = 0.12 * (1 - t2 * 3);
    if (alpha <= 0) continue;

    ctx.strokeStyle = `rgba(44, 143, 123, ${alpha})`;
    ctx.lineWidth = 2;
    ctx.shadowColor = 'rgba(44, 143, 123, 0.3)';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.moveTo(0, y + waveOffset);
    for (let x = 0; x <= W; x += W / 60) {
      const wave = Math.sin(time + x * 0.003 + i * 0.3) * (2 + t2 * 5);
      ctx.lineTo(x, y + waveOffset + wave);
    }
    ctx.stroke();
    ctx.shadowBlur = 0;
  }

  // Shimmer / reflections
  for (let i = 0; i < 30; i++) {
    const rx = (Math.sin(time * 0.3 + i * 7.3) * 0.5 + 0.5) * W;
    const ry = horizonY + Math.pow(Math.random(), 0.5) * (H - horizonY) * 0.7;
    const rw = 10 + Math.random() * 40;
    const alpha = 0.02 + Math.sin(time * 2 + i * 3) * 0.015;
    ctx.fillStyle = `rgba(44, 143, 123, ${Math.max(0, alpha)})`;
    ctx.fillRect(rx - rw / 2, ry, rw, 1.5);
  }

  // --- SUN REFLECTION — shimmering columns ---
  const refCx = W * 0.5;
  const refTop = horizonY;
  const refBot = H * 0.85;
  const colCount = 12;
  const colMaxW = W * 0.012;

  for (let i = 0; i < colCount; i++) {
    const spread = (i - colCount / 2 + 0.5) / (colCount / 2);
    const baseX = refCx + spread * W * 0.06;
    const colAlpha = 0.08 * (1 - Math.abs(spread));

    ctx.fillStyle = `rgba(255, 159, 28, ${Math.max(0, colAlpha)})`;
    ctx.beginPath();

    const segCount = 20;
    for (let s = 0; s <= segCount; s++) {
      const st = s / segCount;
      const sy = refTop + st * (refBot - refTop);
      const wobble = Math.sin(time * 2 + st * 8 + i * 1.5) * (colMaxW * 0.6 + st * colMaxW);
      const fadeW = colMaxW * (1 + st * 1.5) * (1 - Math.abs(spread) * 0.5);
      if (s === 0) ctx.moveTo(baseX - fadeW + wobble, sy);
      else ctx.lineTo(baseX - fadeW + wobble, sy);
    }
    for (let s = segCount; s >= 0; s--) {
      const st = s / segCount;
      const sy = refTop + st * (refBot - refTop);
      const wobble = Math.sin(time * 2 + st * 8 + i * 1.5 + 1) * (colMaxW * 0.6 + st * colMaxW);
      const fadeW = colMaxW * (1 + st * 1.5) * (1 - Math.abs(spread) * 0.5);
      ctx.lineTo(baseX + fadeW + wobble, sy);
    }
    ctx.closePath();
    ctx.fill();
  }

  // Central bright reflection line
  const brightAlpha = 0.06 + Math.sin(time * 1.3) * 0.02;
  ctx.strokeStyle = `rgba(255, 220, 100, ${brightAlpha})`;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(refCx, refTop);
  for (let s = 0; s <= 30; s++) {
    const st = s / 30;
    const sy = refTop + st * (refBot - refTop);
    const wobble = Math.sin(time * 2.5 + st * 10) * (3 + st * 8);
    ctx.lineTo(refCx + wobble, sy);
  }
  ctx.stroke();
}

// --- SKY ---
function drawSky(t) {
  const time = t * 0.001;
  // Slow ambient hue shift — very subtle warmth breathing
  const warmShift = Math.sin(time * 0.08) * 0.015;

  const grad = ctx.createLinearGradient(0, 0, 0, H * 0.55);
  grad.addColorStop(0, COLORS.skyTop);
  grad.addColorStop(0.5, COLORS.skyMid);
  grad.addColorStop(0.85, COLORS.skyLow);
  grad.addColorStop(1, COLORS.horizon);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H * 0.55);

  // Atmospheric glow behind sun
  const glowGrad = ctx.createRadialGradient(W * 0.5, H * 0.35, 0, W * 0.5, H * 0.35, H * 0.35);
  glowGrad.addColorStop(0, `rgba(255, 107, 53, ${0.08 + warmShift})`);
  glowGrad.addColorStop(0.4, `rgba(44, 143, 123, ${0.02 + warmShift * 0.5})`);
  glowGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = glowGrad;
  ctx.fillRect(0, 0, W, H * 0.6);
}

function drawStars(t) {
  const time = t * 0.001;
  stars.forEach(s => {
    const alpha = 0.3 + Math.sin(time * s.speed + s.twinkle) * 0.3;
    ctx.fillStyle = `rgba(255, 255, 255, ${Math.max(0.05, alpha)})`;
    ctx.beginPath();
    ctx.arc(s.x * W, s.y * H, s.r, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawShootingStars(t) {
  if (Math.random() < 0.003) spawnShootingStar();

  for (let i = shootingStars.length - 1; i >= 0; i--) {
    const s = shootingStars[i];
    s.life -= s.decay;
    if (s.life <= 0) {
      shootingStars.splice(i, 1);
      continue;
    }

    const x = s.x * W;
    const y = s.y * H;
    const tailX = (s.x - s.vx * s.len) * W;
    const tailY = (s.y - s.vy * s.len) * H;

    const grad = ctx.createLinearGradient(tailX, tailY, x, y);
    grad.addColorStop(0, 'rgba(255, 255, 255, 0)');
    grad.addColorStop(1, `rgba(255, 255, 255, ${s.life * 0.8})`);

    ctx.strokeStyle = grad;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(tailX, tailY);
    ctx.lineTo(x, y);
    ctx.stroke();

    ctx.fillStyle = `rgba(255, 255, 255, ${s.life})`;
    ctx.beginPath();
    ctx.arc(x, y, 1.5, 0, Math.PI * 2);
    ctx.fill();

    s.x += s.vx * 0.002;
    s.y += s.vy * 0.002;
  }
}

function drawDistantBirds(t) {
  const time = t * 0.001;
  distantBirds.forEach(b => {
    b.x += b.speed;
    if (b.x > 1.15) b.x = -0.05;

    const x = b.x * W;
    const y = (b.y + Math.sin(time * 0.4 + b.flapPhase) * 0.005) * H;
    const wingSpan = b.size;
    const wingY = Math.sin(time * b.flapSpeed + b.flapPhase) * wingSpan * 0.5;

    ctx.strokeStyle = 'rgba(10, 20, 30, 0.5)';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(x - wingSpan, y + wingY);
    ctx.quadraticCurveTo(x - wingSpan * 0.3, y - wingY * 0.3, x, y);
    ctx.quadraticCurveTo(x + wingSpan * 0.3, y - wingY * 0.3, x + wingSpan, y + wingY);
    ctx.stroke();
  });
}

function drawClouds(t) {
  clouds.forEach(c => {
    c.x += c.speed;
    if (c.x > 1.3) c.x = -0.25;

    c.puffs.forEach(p => {
      const x = (c.x + p.ox) * W;
      const y = (c.y + p.oy) * H;
      const w = p.w * W;
      const h = p.h * H;

      const grad = ctx.createRadialGradient(x, y, 0, x, y, w);
      grad.addColorStop(0, `rgba(30, 90, 110, ${p.opacity})`);
      grad.addColorStop(0.6, `rgba(20, 70, 90, ${p.opacity * 0.5})`);
      grad.addColorStop(1, 'rgba(20, 70, 90, 0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(x, y, w, h, 0, 0, Math.PI * 2);
      ctx.fill();
    });
  });
}

// --- PARTICLES with glow halos ---
const particles = [];
for (let i = 0; i < 40; i++) {
  particles.push({
    x: Math.random(),
    y: 0.3 + Math.random() * 0.35,
    phase: Math.random() * Math.PI * 2,
    size: Math.random() * 2 + 0.5,
  });
}

function drawParticles(t) {
  const time = t * 0.001;
  particles.forEach(p => {
    const alpha = 0.2 + Math.sin(time * 2 + p.phase) * 0.2;
    const x = (p.x + Math.sin(time * 0.5 + p.phase) * 0.02) * W;
    const y = (p.y + Math.cos(time * 0.3 + p.phase) * 0.01) * H;
    const a = Math.max(0, alpha);

    // Soft glow halo
    const glowR = p.size * 5;
    const glowGrad = ctx.createRadialGradient(x, y, 0, x, y, glowR);
    glowGrad.addColorStop(0, `rgba(44, 143, 123, ${a * 0.25})`);
    glowGrad.addColorStop(1, 'rgba(44, 143, 123, 0)');
    ctx.fillStyle = glowGrad;
    ctx.beginPath();
    ctx.arc(x, y, glowR, 0, Math.PI * 2);
    ctx.fill();

    // Bright core
    ctx.fillStyle = `rgba(44, 143, 123, ${a})`;
    ctx.beginPath();
    ctx.arc(x, y, p.size, 0, Math.PI * 2);
    ctx.fill();
  });
}

// --- CRT SCANLINES ---
let scanlinePattern = null;
function buildScanlinePattern() {
  const patCanvas = document.createElement('canvas');
  patCanvas.width = 4;
  patCanvas.height = 4;
  const patCtx = patCanvas.getContext('2d');
  patCtx.fillStyle = 'rgba(0, 0, 0, 0.06)';
  patCtx.fillRect(0, 0, 4, 2);
  scanlinePattern = ctx.createPattern(patCanvas, 'repeat');
}

function drawScanlines() {
  if (!scanlinePattern) buildScanlinePattern();
  ctx.fillStyle = scanlinePattern;
  ctx.fillRect(0, 0, W, H);
}

// --- FOREGROUND DEPTH GRADIENT ---
// Dark gradient at bottom edge to ground the scene
function drawForegroundDepth() {
  const gradH = H * 0.12;
  const grad = ctx.createLinearGradient(0, H - gradH, 0, H);
  grad.addColorStop(0, 'rgba(3, 10, 18, 0)');
  grad.addColorStop(0.6, 'rgba(3, 10, 18, 0.3)');
  grad.addColorStop(1, 'rgba(3, 10, 18, 0.6)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, H - gradH, W, gradH);
}

// --- MAIN LOOP ---
function draw(t) {
  ctx.clearRect(0, 0, W, H);

  const sway = Math.sin(t * 0.001) * 0.04;

  // Layer 1: Sky
  drawSky(t);
  drawStars(t);
  drawShootingStars(t);
  drawClouds(t);
  drawDistantBirds(t);

  // Layer 2: Sun + horizon atmosphere
  drawSun(t);
  drawAtmosphericHaze(t);
  drawHorizonGlow(t);

  // Layer 3: Ocean
  drawOcean(t);

  // Layer 4: Island + vegetation
  drawIsland(t);

  // Layer 5: Island palm trees
  const baseY = H * 0.50;
  drawPalmTree(W * 0.42, baseY, H * 0.22, sway, -0.15, false);
  drawPalmTree(W * 0.50, baseY - H * 0.01, H * 0.28, sway * 0.8, 0.05, false);
  drawPalmTree(W * 0.57, baseY, H * 0.20, sway * 1.1, 0.18, false);

  // Layer 6: Parrots (midground)
  parrots.forEach(p => p.draw(t));

  // Layer 7: Floating particles
  drawParticles(t);

  // Layer 8: Foreground silhouette palms
  ctx.globalAlpha = 0.85;
  drawPalmTree(W * 0.05, H * 0.85, H * 0.45, sway * 0.6, -0.2, true);
  drawPalmTree(W * 0.92, H * 0.88, H * 0.42, sway * 0.7, 0.15, true);
  ctx.globalAlpha = 1;

  // Layer 9: Foreground depth
  drawForegroundDepth();

  // Layer 10: Post-processing
  // Vignette
  const vigGrad = ctx.createRadialGradient(W * 0.5, H * 0.5, W * 0.2, W * 0.5, H * 0.5, W * 0.7);
  vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
  vigGrad.addColorStop(1, 'rgba(0,0,0,0.4)');
  ctx.fillStyle = vigGrad;
  ctx.fillRect(0, 0, W, H);

  // CRT scanlines
  drawScanlines();

  requestAnimationFrame(draw);
}

requestAnimationFrame(draw);
</script>
</body>
</html>
